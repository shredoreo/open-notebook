## 3.1 渲染层和逻辑层

小程序的运行环境分成渲染层和逻辑层，第2章提到过 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。小程序的渲染层和逻辑层分离是经过很多考虑得出来的模型，在第6章我们会详细阐述这个模型背后的原理以及产生的问题。在本章我们会先介绍这个模型的基本工作方式。

### 3.1.1 渲染“Hello World”页面

我们看看小程序是如何把脚本里边的数据渲染在界面上的。
WXML模板使用 view 标签，其子节点用 {{ }} 的语法绑定一个 msg 的变量，如代码清单3-1所示。
代码清单3-1 渲染“Hello World”WXML代码

```html
<view>{{ msg }}</view>
```

在 JS 脚本使用 **this.setData 方法把 msg 字段设置成 “Hello World”** ，如代码清单3-2所示。
代码清单3-2 渲染“Hello World”JS脚本

```javascript
Page({
  onLoad: function () {
    this.setData({ msg: 'Hello World' })
  }
})
```

从这个例子我们可以看到3个点：
**1.渲染层和数据相关。**
**2.逻辑层负责产生、处理数据。**
**3.逻辑层通过 Page 实例的 setData 方法传递数据到渲染层。**

关于第1点，涉及了“**数据驱动**”的概念，我们会在3.1.3节详细讨论，我们现在先看看第3点涉及的“**通信模型**”。

### 3.1.2 通信模型

小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了**WebView** 进行渲染；逻辑层采用**JsCore**线程运行JS脚本。一个小程序存在多个界面，所以<u>渲染层存在多个WebView线程</u>，这两个线程的通信会经由微信客户端（下文中也会采用<u>Native来代指微信客户端）做中转</u>，<u>逻辑层发送网络请求也经由Native转发</u>，小程序的通信模型如图3-1所示。

![](asserts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83/%E4%B8%8B%E8%BD%BD.png)

### 3.1.3 数据驱动

##### 数据驱动：让状态和视图绑定在一起

在开发UI界面过程中，程序需要维护很多变量状态，同时要操作对应的UI元素。随着界面越来越复杂，我们需要维护很多变量状态，同时要处理很多界面上的交互事件，整个程序变得越来越复杂。通常界面视图和变量状态是相关联的，<u>如果有某种“方法”可以**让状态和视图绑定在一起**（状态变更时，视图也能自动变更），那我们就可以省去手动修改视图的工作。</u>
这个方法就是“**数据驱动**”，下边我们来介绍一下小程序的数据驱动基本原理。

##### Dom树

WXML结构实际上等价于一棵**Dom树**，通过一个JS对象也可以来表达Dom树的结构，如图3-2所示。

![](asserts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83/%E4%B8%8B%E8%BD%BD%20(1).png)



##### WXML可以先转成JS对象，然后再渲染出真正的Dom树

WXML可以**先转成JS对象**，然后再渲染出真正的Dom树，回到“Hello World”那个例子，我们可以看到转换的过程如图3-3所示。

![](asserts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83/%E5%9B%BE3-3%20WXML%E7%BB%93%E6%9E%84%E8%BD%ACJS%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%86%8D%E8%BD%ACDom%E6%A0%91.png)

##### “数据驱动”的原理：差异对比，修改差异

通过setData把msg数据从“Hello World”变成“Goodbye”，产生的JS对象对应的节点就会发生变化，此时可以**对比前后两个JS对象得到变化的部分，然后把这个差异应用到原来的Dom树上**，从而达到更新UI的目的，这就是“数据驱动”的原理，如图3-4所示。

![](asserts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83/%E5%9B%BE3-4%20%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%80%9A%E8%BF%87%E5%AF%B9%E6%AF%94%E5%89%8D%E5%90%8EJS%E5%AF%B9%E8%B1%A1%E5%8F%98%E5%8C%96%EF%BC%8C%E8%BF%9B%E8%80%8C%E6%94%B9%E5%8F%98%E8%A7%86%E5%9B%BE%E5%B1%82%E7%9A%84Dom%E6%A0%91.png)

### 3.1.4 双线程下的界面渲染

小程序的逻辑层和渲染层是分开的两个线程。<u>在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生**数据变更**的时候，我们需要通过宿主环境提供的**setData方法**把数据从逻辑层传递到渲染层，再经过**对比前后差异**，把**差异应用**在原来的Dom树上，渲染出正确的UI界面</u>，如图3-5所示。

![](asserts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83/%E5%9B%BE3-5%20%E9%80%BB%E8%BE%91%E5%B1%82%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E5%88%B0%E6%B8%B2%E6%9F%93%E5%B1%82.png)